use std::env;
use std::fs;
use std::path::Path;

const COMMANDS: &[&str] = &["ping"];

fn main() {
    // Declare cfg flags for Tauri platform detection
    // This allows the code to compile during cargo package even when these flags aren't set
    println!("cargo::rustc-check-cfg=cfg(desktop)");
    println!("cargo::rustc-check-cfg=cfg(mobile)");
    // Check if we're running during cargo package
    // During packaging, cargo copies source files to target/package/ and runs build.rs
    // We detect this by checking if CARGO_MANIFEST_DIR or OUT_DIR contains "target/package"
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap_or_default();
    let out_dir = env::var("OUT_DIR").unwrap_or_default();
    let is_packaging = manifest_dir.contains("target/package") || out_dir.contains("target/package");
    
    // Check if autogenerated files already exist
    let autogenerated_commands_dir = Path::new("permissions/autogenerated/commands");
    let files_exist = autogenerated_commands_dir.exists()
        && fs::read_dir(autogenerated_commands_dir)
            .map_or(false, |dir| dir.count() > 0);
    
    // Skip generation if we're packaging and files already exist
    // This prevents modifying the source directory during cargo package
    // The permissions directory (including autogenerated files) is included in the package
    // via the include field in Cargo.toml, so they should already be present
    if is_packaging && files_exist {
        println!("cargo:warning=Skipping permission generation during packaging - files already exist");
        return;
    }
    
    tauri_plugin::Builder::new(COMMANDS)
        .android_path("android")
        .ios_path("ios")
        .build();
}
